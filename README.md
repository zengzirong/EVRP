## TLD-EVRP: A Modern Implementation of the Time and Load-dependent Electric Vehicle Routing Problem

This is a modern implementation of the time and load-dependent electric vehicle routing problem (TLD-EVRP) using a large neighborhood search algorithm, optimized with local search operators and a set partitioning model.



## File Structure

#### **cola_new**

This directory stores files from the Singapore Coca-Cola Company and small-scale datasets.

- `Customer2ID.txt`: The customer numbers in the data files are serial numbers generated by Coca-Cola. e.g. 502785770. This file will map such serial numbers to the virtual numbers from 1 to 1987.

- `resource.txt`: This file contains the original resources from the Coca-Cola Company. Each line describes a customer with its serial number, organization's name, and position.

-  `ODMatrix.txt`: This file is a distance matrix file. Each row contains three numbers (a, b, c), where a and b are customers' virtual numbers and c is the distance between a and b in real life.

#### **src**

This directory stores all implementation variants of the algorithm.

#### **dataset**

This directory stores all large-scale datasets.

#### results

This directory stores all final results.



## Input Format

Below is a simple description of an input file.

```
VehicleNumber
VechicleCapacity
Electricity

[Node]
...(not used)

[pickup]
PickupId1 CustomerId1 Demand1 ServeTime1
PickupId2 CustomerId2 Demand2 ServeTime2
...

[Speed 1]
InitialSpeed1
StartTime1_1 EndTime1_1 FloatNumber1_1 Speed1_1
StartTime1_2 EndTime1_2 FloatNumber1_2 Speed1_2
...
[Speed 2]
InitialSpeed2
...

[speed choice matrix]
...(describes the chosen speed id between each pair of nodes)
```

VehicleNumber is assumed to be equal to the number of customers. Node 0 is considered to be the repository.

The difference between a large-scale dataset and a small-scale dataset is that the speed choice matrix of a large-scale dataset is of size $(n+1) \times (n+1)$, while the speed choice matrix of a small-scale dataset is of size $(n+2) \times (n+2)$, where $n$ denotes the number of customers. In small-scale datasets, we assume Node $(n+1)$ to be equivalent to Node $0$.  



## Installation

- Gurobi-12.0.0

- clang-13

  

## Compiling the Code

Assume Gurobi is installed at:

```
/Library/gurobi1200/macos_universal2/
```

You can compile the programs using the following commands:

```
cd src
GUROBI_HOME="/Library/gurobi1200/macos_universal2/"
clang++ <file_name>.cpp -I${GUROBI_HOME}/include/ -L${GUROBI_HOME}/lib -lgurobi_c++ -lgurobi120 -o <executable_name>
```

For example, to compile `main.cpp`, you can run the following command:

``` 
clang++ main.cpp -I${GUROBI_HOME}/include/ -L${GUROBI_HOME}/lib -lgurobi_c++ -lgurobi120 -o main
```



## Running the Executables

```./<executable_name> <data_file_path>
./<executable_name> <data_file_path>
```

 `<data_file_path>` should be a relative path from the root directory of the project.

An example of running this is as follows:

```
./main dataset/Q=1000_200_1.txt
```







